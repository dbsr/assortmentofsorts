// Generated by CoffeeScript 1.6.3
/*
  noQuery v0.2

  author:       Daan Mathot
  email:        daanmathot@gmail.com
  description:  dom traversal and manipulation utilities
  license:      UNLICENSE
*/

var namespace,
  __slice = [].slice;

namespace = function(target, name, block) {
  var item, top, _i, _len, _ref, _ref1;
  if (arguments.length < 3) {
    _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
  }
  top = target;
  _ref1 = name.split('.');
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    item = _ref1[_i];
    target = target[item] || (target[item] = {});
  }
  return block(target, top);
};

namespace("nQ", function(exports) {
  exports.nq_wrap = function(selector) {
    var n;
    n = new nQ.NoQuery(selector);
    if (n.node) {
      return n;
    } else if (n.nodes) {
      return n.nodes;
    }
  };
  exports.NoQuery = (function() {
    function NoQuery(selector) {
      var sElements;
      this.selector = selector;
      switch (typeof this.selector) {
        case 'object' && this.selector instanceof Node:
          this.node = this.selector;
          this.selector = null;
          break;
        case 'string':
          sElements = this.select(this.selector);
          if (sElements instanceof HTMLCollection && sElements.length > 0) {
            if (sElements.length === 1) {
              this.node = sElements[0];
            } else {
              this.nodes = Array.prototype.slice.call(sElements);
            }
          } else if (sElements instanceof Node) {
            this.node = sElements;
          }
      }
    }

    NoQuery.prototype.select = function(selector) {
      var parent, sSplit, sType;
      parent = this.node != null ? this.node : document;
      sType = selector[0];
      sSplit = selector.slice(1);
      switch (sType) {
        case "#":
          return document.getElementById(sSplit);
        case ".":
          return parent.getElementsByClassName(sSplit);
        default:
          return parent.getElementsByTagName(selector);
      }
    };

    NoQuery.prototype.append = function(html) {
      return this.node.appendChild(nQ.dom.createFrag(html));
    };

    NoQuery.prototype.appendTo = function(selector) {
      return nQ.nq_wrap(selector).append(this.node);
    };

    NoQuery.prototype.prepend = function(html) {
      return this.node.insertBefore(nQ.dom.createFrag(html), this.node.firstChild);
    };

    NoQuery.prototype.prependTo = function(selector) {
      return nQ.nq_wrap(selector).prepend(this.node);
    };

    NoQuery.prototype.remove = function() {
      return this.node.parentNode.removeChild(this.node);
    };

    NoQuery.prototype.replaceChild = function(html) {
      return this.node.replaceChild(html, this.node.firstChild);
    };

    NoQuery.prototype.attr = function(attr, value) {
      if (value == null) {
        value = null;
      }
      if (value != null) {
        return nQ.attribute.set(this.node, attr, value);
      } else {
        return nQ.attribute.get(this.node, attr);
      }
    };

    NoQuery.prototype.hasClass = function(className) {
      return nQ.klass.has(this.node, className);
    };

    NoQuery.prototype.addClass = function(className) {
      return nQ.klass.add(this.node, className);
    };

    NoQuery.prototype.removeClass = function(className) {
      return nQ.klass.remove(this.node, className);
    };

    NoQuery.prototype.toggleClass = function(className) {
      return nQ.klass.toggle(this.node, className);
    };

    NoQuery.prototype.toggleHide = function() {
      return nQ.style.toggleHide(this.node);
    };

    NoQuery.prototype.css = function(cssStyles) {
      return nQ.style.css(this.node, cssStyles);
    };

    NoQuery.prototype.value = function() {
      return this.node.value;
    };

    return NoQuery;

  })();
  /*
  noQuery functions
  */

  exports.dom = {
    createFrag: function(html) {
      /*
      Used by append and prepend functions. Text is detected by looking 1 token
      ahead. If this is not an opening < tag, assumes textNode.
      @TODO style tag implementation switch to YAML syntax?
      
      args
        html: <string> html formatted text string
      
      returns: <fragmentNode> with childNodes parsed from html string
      */

      var attr, e, e_obj, element, frag, k, text, textIdx, v, x, _i, _j, _len, _len1, _ref, _ref1;
      if (typeof html !== 'string') {
        return html;
      }
      frag = document.createDocumentFragment();
      _ref = html.match(/<[^>]+>/g);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        text = null;
        textIdx = html.indexOf(e) + e.length;
        if (html[textIdx] !== "<") {
          text = document.createTextNode(html.slice(textIdx, +(textIdx + html.slice(textIdx).search(/</) - 1) + 1 || 9e9));
        }
        if (e.match(/\//)) {
          continue;
        }
        e_obj = {};
        _ref1 = (function() {
          var _k, _len1, _ref1, _results;
          _ref1 = e.split(" ");
          _results = [];
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            x = _ref1[_k];
            _results.push(x.replace(/[\<\>\s]/g, ''));
          }
          return _results;
        })();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          attr = _ref1[_j];
          if (attr.match(/\=/)) {
            e_obj[attr.split("=")[0]] = attr.split("=")[1].replace(/["']/g, '');
          } else {
            e_obj.tag = attr;
          }
        }
        element = document.createElement(e_obj.tag);
        if (text != null) {
          element.appendChild(text);
        }
        for (k in e_obj) {
          v = e_obj[k];
          if (k !== 'tag') {
            element.setAttribute(k, v);
          }
        }
        frag.appendChild(element);
      }
      return frag;
    }
  };
  exports.attribute = {
    has: function(elem, attr) {
      return elem.hasAttribute(attr);
    },
    get: function(elem, attr) {
      if (this.has(elem, attr)) {
        return elem.getAttribute(attr);
      }
    },
    set: function(elem, attr, value) {
      if (value !== false) {
        return elem.setAttribute(attr, value);
      } else {
        return this.remove(elem, attr);
      }
    },
    remove: function(elem, attr) {
      return elem.removeAttribute(attr);
    }
  };
  exports.klass = {
    /*
    Except for OperaMini all modern browsers support classList. Suck it oldtimers.
    @TODO regex based alternative for classListless browsers.
    */

    has: function(elem, c) {
      return elem.classList.contains(c);
    },
    add: function(elem, c) {
      return elem.classList.add(c);
    },
    remove: function(elem, c) {
      return elem.classList.remove(c);
    },
    toggle: function(elem, c) {
      if (this.hasClass(elem, c)) {
        return removeClass(elem, c);
      } else {
        return addClass(elem, c);
      }
    }
  };
  return exports.style = {
    css: function(elem, cssStyle) {
      var k, v, _results;
      _results = [];
      for (k in cssStyle) {
        v = cssStyle[k];
        _results.push(elem.style[k] = v);
      }
      return _results;
    },
    toggleHide: function(elem) {
      return elem.style.display = elem.style.display === "none" ? "" : "none";
    }
  };
});

window._$ = nQ.nq_wrap;
